---
phase: 02-server-test-coverage
plan: 04
type: tdd
wave: 1
depends_on: []
files_modified:
  - server/__tests__/pacing-controller.test.ts
autonomous: true

must_haves:
  truths:
    - "PacingController.getPacingConfig returns correct configuration for each distress level"
    - "Session fatigue detection triggers gentle closure rituals"
    - "High-distress scenarios enforce protective pacing (short responses, exit options)"
  artifacts:
    - path: "server/__tests__/pacing-controller.test.ts"
      provides: "Comprehensive pacing controller tests"
      min_lines: 100
      exports: []
  key_links:
    - from: "server/__tests__/pacing-controller.test.ts"
      to: "server/pacing-controller.ts"
      via: "import PacingController"
      pattern: "import.*PacingController.*from.*pacing-controller"
---

<objective>
Add comprehensive unit tests for server/pacing-controller.ts covering pacing logic, session fatigue detection, and closure rituals.

Purpose: Ensure protective pacing mechanisms work correctly for all distress levels - critical for user safety.

Output: Complete test suite with TDD-driven implementation verification.
</objective>

<execution_context>
@C:\Users\richa\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\richa\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-server-test-coverage/02-CONTEXT.md
@server/pacing-controller.ts
@server/__tests__/conversational-ai.test.ts
</context>

<feature>
  <name>Pacing Controller Test Suite</name>
  <files>
    - server/__tests__/pacing-controller.test.ts
    - server/pacing-controller.ts
  </files>
  <behavior>
**Test Coverage Areas:**

1. **getPacingConfig** - Pacing configuration for different distress levels
   - Crisis/high distress → 1.5s delay, 200 char max, requires permission, shows exit
   - Repetition detected (2+) → 1s delay, 250 char max, permission required
   - Moderate distress → 500ms delay, 400 char max
   - Low/minimal → 0ms delay, 600 char max
   - Edge cases: undefined repetition count, unknown distress levels

2. **shouldOfferExit** - Exit offering logic
   - Duration >20 min → offer exit
   - Distress high/crisis + interaction count >5 → offer exit
   - Interaction count >15 → offer exit
   - Crisis detected → always offer exit
   - Repetition count ≥3 → offer exit
   - Normal conditions → no exit offered

3. **getClosureRitual** - Gentle session endings
   - Returns ritual with acknowledgment, validation, invitation, blessing
   - noGuilt flag always true
   - Language matches distress level (gentle for high distress)
   - Validates all required fields present

**Expected Patterns:**
- Higher distress = slower pacing, shorter responses, more protection
- Fatigue detection triggers protective interventions
- Closure rituals always compassionate and guilt-free
- All pacing decisions prioritize user safety over engagement
  </behavior>
  <implementation>
Follow TDD RED-GREEN-REFACTOR cycle:

**RED Phase:**
1. Create test file server/__tests__/pacing-controller.test.ts
2. Write failing tests for all PacingController methods
3. Organize tests by method (getPacingConfig, shouldOfferExit, getClosureRitual)
4. Run tests - verify they fail (module works but tests validate behavior)
5. Commit: `test(02-04): add failing tests for pacing-controller`

**GREEN Phase:**
1. Review test failures - verify tests correctly validate pacing logic
2. Run tests again - should pass (pacing-controller.ts already implemented)
3. Verify coverage includes all distress levels and edge cases
4. Commit: `test(02-04): verify pacing-controller test coverage`

**REFACTOR Phase (if needed):**
1. Improve test readability with describe blocks and clear test names
2. Add test fixtures/factories if repetitive test data
3. Ensure tests are maintainable and well-documented
4. Run tests - must still pass
5. Commit only if changes made: `refactor(02-04): improve pacing-controller test structure`

**Coverage Target:** >80% for pacing-controller.ts

**Mocking Strategy:**
- No external dependencies to mock (pure logic)
- Use realistic test data matching production distress patterns
- Test all distress levels: crisis, high, moderate, low, minimal
  </implementation>
</feature>

<verification>
Run test suite:
```bash
npm test -- pacing-controller.test.ts
```

Check coverage:
```bash
npm test -- --coverage --testPathPattern=pacing-controller
```

Success criteria:
- All tests passing
- >80% coverage for pacing-controller.ts
- All distress levels tested
- All methods covered
</verification>

<success_criteria>
1. Test file exists at server/__tests__/pacing-controller.test.ts
2. Tests cover all 3 main methods (getPacingConfig, shouldOfferExit, getClosureRitual)
3. All distress levels tested (crisis, high, moderate, low, minimal)
4. Edge cases covered (undefined values, repetition counts, long sessions)
5. >80% code coverage for pacing-controller.ts
6. All tests passing
7. Test code is readable and maintainable
</success_criteria>

<output>
After completion, create `.planning/phases/02-server-test-coverage/02-04-SUMMARY.md`
</output>
