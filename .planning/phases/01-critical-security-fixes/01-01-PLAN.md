---
phase: 01-critical-security-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/encryption.ts
autonomous: true

must_haves:
  truths:
    - "Encryption failures throw errors instead of returning plaintext"
    - "Decryption failures throw errors instead of returning encrypted text"
    - "Calling code has try-catch blocks to handle encryption errors gracefully"
    - "HIPAA compliance maintained: error handlers never log or expose plaintext sensitive data"
  artifacts:
    - path: "server/encryption.ts"
      provides: "Fail-closed encryption/decryption functions"
      contains: "throw new Error"
    - path: "server/routes.ts"
      provides: "Error handling around encryption calls"
      contains: "try {"
    - path: "server/middleware/auth.ts"
      provides: "Error handling around encryption calls"
      contains: "try {"
  key_links:
    - from: "server/encryption.ts"
      to: "catch block"
      via: "error throw instead of return"
      pattern: "throw new Error.*encryption failed"
    - from: "server/routes.ts"
      to: "server/encryption.ts"
      via: "try-catch wrapped calls"
      pattern: "try.*encryptData|decryptData"
---

<objective>
Fix encryption fallback behavior to throw errors instead of silently returning plaintext or encrypted text.

Purpose: Eliminate critical HIPAA violation risk where encryption/decryption failures could expose sensitive user data in plaintext.

Output: Modified encryption.ts that fails closed on any encryption or decryption error, with all calling code properly handling these errors.

**IMPORTANT:** This plan includes Task 4 to add error handling to all calling code (routes.ts, auth.ts). Task 4 ensures that the behavior change in encryption.ts (throwing errors instead of returning plaintext) does not break existing functionality. All four tasks in this plan must complete together to maintain system stability.
</objective>

<execution_context>
@C:\Users\richa\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\richa\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@server/encryption.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix encryptData fallback behavior</name>
  <files>server/encryption.ts</files>
  <action>
In `server/encryption.ts`, modify the `encryptData` function catch block (around lines 67-70):

CURRENT CODE (DANGEROUS):
```typescript
} catch (error) {
  console.error("[Encryption] Encryption failed:", error);
  return text; // Fallback to plaintext in dev
}
```

CHANGE TO:
```typescript
} catch (error) {
  console.error("[Encryption] Encryption failed:", error);
  throw new Error(`Encryption failed: ${error instanceof Error ? error.message : String(error)}`);
}
```

This ensures encryption failures are never silent and always propagate up the call stack. Remove the comment "Fallback to plaintext in dev" as this behavior is being eliminated.
  </action>
  <verify>
- TypeScript compilation passes: `npx tsc --noEmit`
- Function now throws on error instead of returning plaintext
  </verify>
  <done>encryptData throws Error on any encryption failure</done>
</task>

<task type="auto">
  <name>Task 2: Fix decryptData fallback behavior</name>
  <files>server/encryption.ts</files>
  <action>
In `server/encryption.ts`, modify the `decryptData` function catch block (around lines 105-108):

CURRENT CODE (DANGEROUS):
```typescript
} catch (error) {
  console.error("[Encryption] Decryption failed:", error);
  return encryptedText; // Fallback
}
```

CHANGE TO:
```typescript
} catch (error) {
  console.error("[Encryption] Decryption failed:", error);
  throw new Error(`Decryption failed: ${error instanceof Error ? error.message : String(error)}`);
}
```

This ensures decryption failures propagate up and are handled explicitly by calling code. The calling code should have appropriate error handling for production scenarios.
  </action>
  <verify>
- TypeScript compilation passes: `npx tsc --noEmit`
- Function now throws on error instead of returning encrypted text
  </verify>
  <done>decryptData throws Error on any decryption failure</done>
</task>

<task type="auto">
  <name>Task 3: Verify changes and run tests</name>
  <files>server/encryption.ts</files>
  <action>
1. Run TypeScript type check to ensure no type errors:
   ```bash
   npx tsc --noEmit
   ```

2. Run existing tests to ensure nothing is broken:
   ```bash
   npm test
   ```

3. Verify the encryption module still works by checking the file compiles without errors.

If tests fail due to the new throw behavior, that indicates calling code needs to be updated to handle errors properly - which is the correct behavior.
  </action>
  <verify>
- `npx tsc --noEmit` exits with code 0
- `npm test` passes (or failures are documented as expected due to new error handling)
  </verify>
  <done>Encryption module compiles and tests pass (or failures documented)</done>
</task>

<task type="auto">
  <name>Task 4: Add error handling to calling code</name>
  <files>server/routes.ts, server/middleware/auth.ts</files>
  <action>
The encryption functions now throw errors. Calling code in routes.ts and auth.ts must be wrapped with try-catch blocks to handle these errors gracefully and return appropriate HTTP responses.

In `server/routes.ts` (around lines 839-841), wrap the encryption calls:

```typescript
// Replace direct calls:
const encryptedThought = encryptData(thought);
const encryptedReframe = encryptData(reframe);
const encryptedIntention = intention ? encryptData(intention) : undefined;

// With try-catch:
let encryptedThought: string;
let encryptedReframe: string;
let encryptedIntention: string | undefined;
try {
  encryptedThought = encryptData(thought);
  encryptedReframe = encryptData(reframe);
  encryptedIntention = intention ? encryptData(intention) : undefined;
} catch (error) {
  console.error("[Routes] Encryption failed:", error);
  return res.status(500).json({ error: "Failed to securely store reflection" });
}
```

In `server/routes.ts` (around lines 884-887), wrap the decryption calls:

```typescript
// Wrap decryption in try-catch
try {
  return {
    ...reflection,
    thought: decryptData(reflection.thought),
    reframe: decryptData(reflection.reframe),
    intention: reflection.intention
      ? decryptData(reflection.intention)
      : undefined,
  };
} catch (error) {
  console.error("[Routes] Decryption failed for reflection:", reflection.id, error);
  return {
    ...reflection,
    thought: "[Unable to decrypt]",
    reframe: "[Unable to decrypt]",
    intention: reflection.intention ? "[Unable to decrypt]" : undefined,
  };
}
```

In `server/middleware/auth.ts` (around line 108), wrap decryption:

```typescript
// Wrap decryption call
let email: string | null = null;
try {
  email = session.email ? decryptData(session.email) : null;
} catch (error) {
  console.error("[Auth] Failed to decrypt session email:", error);
  // Continue with null email - session still valid
}
```

In `server/middleware/auth.ts` (around line 214), wrap encryption:

```typescript
// Wrap encryption call
let encryptedEmail: string;
try {
  encryptedEmail = encryptData(email);
} catch (error) {
  console.error("[Auth] Failed to encrypt email:", error);
  return res.status(500).json({ error: "Failed to secure user data" });
}
```
  </action>
  <verify>
- `npx tsc --noEmit` exits with code 0
- `npm test` passes
- All encryption/decryption calls are wrapped in try-catch
  </verify>
  <done>All calling code handles encryption errors with appropriate error responses</done>
</task>

</tasks>

<verification>
1. Read `server/encryption.ts` and confirm both catch blocks now throw errors
2. Run `npx tsc --noEmit` to verify TypeScript compilation
3. Run `npm test` to ensure existing tests still pass
4. Confirm no `return text` or `return encryptedText` in catch blocks
</verification>

<success_criteria>
1. `encryptData` throws `Error` on encryption failure (never returns plaintext)
2. `decryptData` throws `Error` on decryption failure (never returns encrypted text)
3. All calling code in routes.ts and auth.ts wrapped with try-catch error handling
4. Encryption errors return appropriate HTTP 500 responses to clients
5. Decryption errors gracefully degrade (show placeholder text, not crash)
6. TypeScript compilation passes
7. Tests pass
8. Code committed with clear commit message referencing SEC-01
</success_criteria>

<output>
After completion, create `.planning/phases/01-critical-security-fixes/01-01-SUMMARY.md`
</output>
