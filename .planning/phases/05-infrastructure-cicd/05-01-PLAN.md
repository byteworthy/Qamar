---
phase: 05-infrastructure-cicd
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .github/workflows/ci.yml
  - .github/workflows/pr-check.yml
  - jest.config.js
autonomous: true

must_haves:
  truths:
    - "CI fails when test coverage drops below 70% on changed files"
    - "CI runs faster due to cached dependencies and build artifacts"
    - "Pull request checks enforce coverage thresholds before merge"
  artifacts:
    - path: ".github/workflows/ci.yml"
      provides: "Coverage threshold enforcement in CI"
      contains: "jest --coverage --coverageThreshold"
    - path: ".github/workflows/pr-check.yml"
      provides: "Coverage threshold enforcement in PR checks"
      contains: "jest --coverage --coverageThreshold"
    - path: "jest.config.js"
      provides: "Coverage threshold configuration"
      contains: "coverageThreshold"
  key_links:
    - from: ".github/workflows/ci.yml"
      to: "jest.config.js"
      via: "npm test command"
      pattern: "npm test.*--coverage"
    - from: ".github/workflows/pr-check.yml"
      to: "node_modules cache"
      via: "actions/cache"
      pattern: "uses: actions/cache"
---

<objective>
Enforce test coverage thresholds and optimize CI/CD performance through caching.

Purpose: Prevent test coverage regressions and reduce CI execution time by caching dependencies and build artifacts. This ensures code quality gates are enforced while maintaining fast feedback loops for developers.

Output: CI workflows with coverage enforcement and caching, preventing merges that reduce coverage below 70% on changed files.
</objective>

<execution_context>
@C:\Users\richa\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\richa\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/STACK.md

# Current CI/CD workflows
@.github/workflows/ci.yml
@.github/workflows/pr-check.yml
@.github/workflows/eas-build.yml

# Test configuration
@jest.config.js
@package.json

# Phase 2 established comprehensive test coverage (500+ tests, >70% coverage)
# This plan ensures that coverage never regresses below thresholds
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add coverage thresholds to Jest configuration</name>
  <files>jest.config.js</files>
  <action>
Add coverage threshold configuration to jest.config.js to enforce 70% coverage on changed files:

```javascript
coverageThreshold: {
  global: {
    statements: 70,
    branches: 70,
    functions: 70,
    lines: 70
  }
}
```

This will cause Jest to fail if coverage drops below 70% in any dimension. The threshold applies globally to ensure consistent quality across the codebase.

Note: Coverage is already tracked (Phase 2 achieved >70% coverage). This task adds enforcement to prevent regressions.
  </action>
  <verify>
Run: `npm test -- --coverage --watchAll=false`
Should pass with current coverage levels. To test enforcement, temporarily lower a threshold (e.g., statements: 95) and verify Jest exits with error code 1.
  </verify>
  <done>
- coverageThreshold configuration added to jest.config.js
- Jest enforces 70% minimum coverage across all dimensions
- Tests pass with current coverage levels
  </done>
</task>

<task type="auto">
  <name>Task 2: Add coverage enforcement to CI workflows</name>
  <files>.github/workflows/ci.yml, .github/workflows/pr-check.yml</files>
  <action>
Update both CI workflows to run tests with coverage enforcement:

In `.github/workflows/ci.yml`, update the "Run release gate" step:
```yaml
- name: Run release gate
  run: npm run release:check
```
(release:check already runs `npm test` which will now enforce coverage)

In `.github/workflows/pr-check.yml`, update the "Run tests" step:
```yaml
- name: Run tests
  run: npm test -- --watchAll=false --coverage
```

The --coverage flag ensures Jest generates coverage reports and enforces thresholds. CI will fail if coverage drops below 70% on any dimension.

Why this works: Jest exits with non-zero code when thresholds are violated, causing GitHub Actions job to fail and blocking PR merge.
  </action>
  <verify>
Run: `git add . && git commit -m "test: verify coverage enforcement"`
Push to a test branch and open a PR. Verify that:
1. PR checks run tests with coverage
2. Coverage thresholds are enforced (check job logs for "PASS" and coverage summary)
3. Job succeeds with current coverage levels

To test failure case: temporarily comment out a test file, push, and verify PR check fails with "Coverage for X (Y%) does not meet threshold (70%)" message.
  </verify>
  <done>
- CI workflow enforces coverage thresholds via npm run release:check
- PR check workflow runs tests with --coverage flag
- GitHub Actions job fails if coverage drops below 70%
- Developers receive immediate feedback on coverage regressions
  </done>
</task>

<task type="auto">
  <name>Task 3: Add caching to CI workflows for faster builds</name>
  <files>.github/workflows/ci.yml, .github/workflows/pr-check.yml, .github/workflows/eas-build.yml</files>
  <action>
Add dependency and build artifact caching to all three workflows to reduce CI execution time.

Pattern to add after "Setup Node.js" step in each workflow:

```yaml
- name: Cache dependencies
  uses: actions/cache@v4
  with:
    path: |
      ~/.npm
      node_modules
    key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
    restore-keys: |
      ${{ runner.os }}-node-
```

Note: All workflows already have `cache: 'npm'` in setup-node@v4 step which caches npm cache directory. This additional caching adds node_modules caching for even faster installs.

For eas-build.yml, also add after dependency cache:
```yaml
- name: Cache Expo
  uses: actions/cache@v4
  with:
    path: ~/.expo
    key: ${{ runner.os }}-expo-${{ hashFiles('**/package-lock.json') }}
    restore-keys: |
      ${{ runner.os }}-expo-
```

Why: Caching node_modules avoids reinstalling unchanged dependencies. Expo cache reduces EAS build preparation time. This can reduce CI time by 30-50% (from ~3min to ~1.5-2min for PR checks).
  </action>
  <verify>
Run workflows twice and compare execution times:
1. First run (cold cache): `npm ci` takes ~2-3 minutes
2. Second run (warm cache): `npm ci` takes ~10-20 seconds (cache hit)

Check job logs for "Cache restored successfully" message. Verify cache key includes package-lock.json hash so cache invalidates when dependencies change.
  </verify>
  <done>
- node_modules cached across workflow runs (keyed by package-lock.json)
- Expo cache added to EAS build workflow
- CI execution time reduced by 30-50% on cache hits
- Cache automatically invalidates when dependencies change
- All three workflows (ci.yml, pr-check.yml, eas-build.yml) have caching enabled
  </done>
</task>

</tasks>

<verification>
1. Run `npm test -- --coverage --watchAll=false` locally - should pass with coverage >70%
2. Temporarily lower coverage threshold to 95% and verify Jest fails with threshold error
3. Push to test branch and verify PR check enforces coverage
4. Check second CI run uses cached dependencies (faster execution)
5. Verify cache invalidates when package-lock.json changes
</verification>

<success_criteria>
1. Jest configuration includes coverageThreshold for all dimensions (statements/branches/functions/lines) at 70%
2. CI workflow (ci.yml) enforces coverage via release:check
3. PR check workflow (pr-check.yml) runs tests with --coverage flag
4. All three workflows cache node_modules and npm dependencies
5. EAS build workflow caches Expo artifacts
6. CI execution time reduced by 30-50% on cache hits
7. Coverage regression blocks PR merge
</success_criteria>

<output>
After completion, create `.planning/phases/05-infrastructure-cicd/05-01-SUMMARY.md`
</output>
